// import React, { useState, useEffect, useRef } from "react";
// import io from "socket.io-client";
// import * as mediasoupClient from "mediasoup-client";
// const socket = io("https://127.0.0.1:8000/mediasoup");

// const MediasoupComponent = () => {
//   const [rtpCapabilities, setRtpCapabilities] = useState(null);
//   // const [device, setDevice] = useState(null);
//   const [producerTransport, setProducerTransport] = useState(null);
//   const [consumerTransports, setConsumerTransports] = useState([]);
//   const [audioProducer, setAudioProducer] = useState(null);
//   const [videoProducer, setVideoProducer] = useState(null);

//   const localVideo = useRef(null);
//   const videoContainer = useRef(null);

//   const roomName = "12";
//   let device;

//   const params = {
//     encodings: [
//       { rid: "r0", maxBitrate: 100000, scalabilityMode: "S1T3" },
//       { rid: "r1", maxBitrate: 300000, scalabilityMode: "S1T3" },
//       { rid: "r2", maxBitrate: 900000, scalabilityMode: "S1T3" },
//     ],
//     codecOptions: { videoGoogleStartBitrate: 1000 },
//   };

//   useEffect(() => {
//     const handleConnectionSuccess = ({ socketId }) => {
//       console.log("socketId ", socketId);
//       getLocalStream();
//     };

//     const handleNewProducer = ({ producerId }) => {
//       console.log("New Producer Event Called:", producerId);
//       signalNewConsumerTransport(producerId);
//     };

//     const handleProducerClosed = ({ remoteProducerId }) => {
//       handleProducerClosed(remoteProducerId);
//     };

//     // Register socket event listeners
//     socket.on("connection-success", handleConnectionSuccess);
//     socket.on("new-producer", handleNewProducer);
//     socket.on("producer-closed", handleProducerClosed);

//     // Cleanup function to remove the event listeners on component unmount
//     return () => {
//       socket.off("connection-success", handleConnectionSuccess);
//       socket.off("new-producer", handleNewProducer);
//       socket.off("producer-closed", handleProducerClosed);
//     };
//   }, []);

//   const getLocalStream = () => {
//     try {
//       navigator.mediaDevices
//         .getUserMedia({
//           audio: true,
//           video: {
//             width: { min: 640, max: 1920 },
//             height: { min: 400, max: 1080 },
//           },
//         })
//         .then((stream) => {
//           streamSuccess(stream);
//         });
//     } catch (error) {
//       console.log("Error accessing local stream", error);
//     }
//   };

//   let audioParams;
//   let videoParams = { params };

//   const streamSuccess = (stream) => {
//     if (localVideo.current) {
//       localVideo.current.srcObject = stream;
//     }
//     audioParams = { track: stream.getAudioTracks()[0], ...audioParams };
//     videoParams = { track: stream.getVideoTracks()[0], ...videoParams };
//     joinRoom(audioParams, videoParams);
//   };

//   const joinRoom = (audioParams, videoParams) => {
//     socket.emit("joinRoom", { roomName }, (data) => {
//       console.log("RTP Capabilities from server:", data.rtpCapabilities);
//       // setRtpCapabilities(data.rtpCapabilities);
//       createDevice(data.rtpCapabilities, audioParams, videoParams);
//     });
//   };

//   const createDevice = async (rtpCapabilities1, audioParams, videoParams) => {
//     try {
//       device = new mediasoupClient.Device();
//       await device.load({ routerRtpCapabilities: rtpCapabilities1 });
//       // setDevice(device);
//       createSendTransport(device, audioParams, videoParams);
//     } catch (error) {
//       console.error("Error creating device", error);
//     }
//   };

//   const createSendTransport = (device, audioParams, videoParams) => {
//     socket.emit("createWebRtcTransport", { consumer: false }, ({ params }) => {
//       if (params.error) {
//         console.log("Error creating transport", params.error);
//         return;
//       }

//       const transport = device.createSendTransport(params);
//       setProducerTransport(transport);

//       transport.on("connect", async ({ dtlsParameters }, callback, errback) => {
//         try {
//           console.log(
//             "helooo---------------------------------------------------"
//           );
//           await socket.emit("transport-connect", { dtlsParameters });
//           callback();
//         } catch (error) {
//           errback(error);
//         }
//       });

//       transport.on(
//         "produce",
//         async ({ kind, rtpParameters, appData }, callback, errback) => {
//           try {
//             await socket.emit(
//               "transport-produce",
//               { kind, rtpParameters, appData },
//               ({ id }) => {
//                 callback({ id });
//                 getProducers(); // Fetch the list of producers once the transport is connected
//               }
//             );
//           } catch (error) {
//             errback(error);
//           }
//         }
//       );

//       connectSendTransport(transport, audioParams, videoParams);
//     });
//   };

//   const connectSendTransport = async (transport, audioParams, videoParams) => {
//     const audioProducer = await transport.produce(audioParams);
//     const videoProducer = await transport.produce(videoParams);

//     setAudioProducer(audioProducer);
//     setVideoProducer(videoProducer);
//   };

//   // Define getProducers to fetch the producers in the room
//   const getProducers = () => {
//     socket.emit("getProducers", (producers) => {
//       producers.forEach((producerId) => signalNewConsumerTransport(producerId));
//     });
//   };

//   const signalNewConsumerTransport = (remoteProducerId) => {
//     socket.emit("createWebRtcTransport", { consumer: true }, ({ params }) => {
//       const transport = device.createRecvTransport(params);
//       console.log("transport ", transport);

//       transport.on("connect", async ({ dtlsParameters }, callback, errback) => {
//         try {
//           await socket.emit("transport-recv-connect", { dtlsParameters });
//           callback();
//         } catch (error) {
//           errback(error);
//         }
//       });

//       connectRecvTransport(transport, remoteProducerId);
//     });
//   };

//   const connectRecvTransport = async (transport, remoteProducerId) => {
//     await socket.emit(
//       "consume",
//       { rtpCapabilities: device.rtpCapabilities, remoteProducerId },
//       async ({ params }) => {
//         if (params.error) {
//           console.log('Cannot Consume')
//           return
//         }

//         console.log(`Consumer Params ${params}`)
//         const consumer = await transport.consume({
//           id: params.id,
//           producerId: params.producerId,
//           kind: params.kind,
//           rtpParameters: params.rtpParameters,
//         });

//         setConsumerTransports((prev) => [
//           ...prev,
//           {
//             consumerTransport: transport,
//             consumer,
//             producerId: remoteProducerId,
//           },
//         ]);

//         const newMediaElement = document.createElement(
//           params.kind === "audio" ? "audio" : "video"
//         );
//         newMediaElement.srcObject = new MediaStream([consumer.track]);
//         newMediaElement.autoplay = true;
//         newMediaElement.id = remoteProducerId;

//         if (videoContainer.current) {
//           videoContainer.current.appendChild(newMediaElement);
//         }

//         socket.emit("consumer-resume", {
//           serverConsumerId: params.serverConsumerId,
//         });
//       }
//     );
//   };

//   const handleProducerClosed = (remoteProducerId) => {
//     const consumerToClose = consumerTransports.find(
//       (t) => t.producerId === remoteProducerId
//     );
//     if (consumerToClose) {
//       consumerToClose.consumerTransport.close();
//       consumerToClose.consumer.close();
//       setConsumerTransports((prev) =>
//         prev.filter((t) => t.producerId !== remoteProducerId)
//       );
//       if (videoContainer.current) {
//         const elem = document.getElementById(remoteProducerId);
//         if (elem) {
//           videoContainer.current.removeChild(elem);
//         }
//       }
//     }
//   };

//   return (
//     <div>
//       <video
//         ref={localVideo}
//         autoPlay
//         muted
//         style={{ width: "300px", height: "200px" }}
//       />
//       <div ref={videoContainer}></div>
//     </div>
//   );
// };

// export default MediasoupComponent;
